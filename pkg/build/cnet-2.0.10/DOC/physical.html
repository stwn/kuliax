<HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HEAD>
<TITLE>The cnet network simulator - Physical Layer</TITLE>
<META NAME="description" CONTENT="cnet enables experimentation
with various data-link layer, network layer, routing and transport
layer networking protocols.  It has been specifically developed for
undergraduate teaching.">

<META NAME="keywords" CONTENT="network, 802.3, ethernet, WAN, simulator,
simulation, protocol, undergraduate, teaching">
</HEAD>

<BODY BGCOLOR="white" TEXT ="black" LINK="blue" VLINK="purple">

<table>
<tr>
<td valign="top" bgcolor="#74dbf2">
<table cellpadding="4" cellspacing="0" border="0"><tr>

<td nowrap>
    <b><i>cnet</i> v2.0.10</b>
    <p>

    <a href="index.html">home</a>
    <br>
    <a href="introduction.html">introduction</a>
    <br>
    <a href="themodel.html">simulation model</a>
    <p>
    <a href="topology.html">topology files</a>
    <br>
    <a href="options.html">cmdline options</a>
    <br>
    <a href="functions.html">the API</a>
    <p>
    <a href="faq.html">FAQ</a>
    <p>
    <a href="install.html">download</a>
</td>

</td></tr></table>
</td>

<td>
<h3><i>cnet's</i> Physical Layer</a></h3>

The Physical Layer
(either the internal default version or one provided with the
<a href="options.html#option-R">-R</a> option)
has the responsibility of delivering data frames between nodes.

Frames are delivered along either <i>point-to-point</i> links
or <i>Ethernet</i> segments.

Each physical link is numbered within each node from 1 to its total
number of links.
As a special case, link 0 represents a <i>loopback</i> link,
and is provided to simply copy a frame immediately from a node's output
to input.
In general, the Physical Layer will randomly corrupt and drop data frames
on all point-to-point links,
but not on the loopback link or Ethernet segments.
<p>
When your protocols wish to transmit a data frame along a link,
they write that frame to the Physical Layer.
On calling the <tt>CNET_write_physical</tt> function,
you indicate the length of the frame to be written and on return
<tt>CNET_write_physical</tt> indicates how many bytes were accepted.
A typical sequence for a network of just 2 nodes,
connected by a single point-to-point link is:

<p>
<table cellpadding="1" cellspacing="0" border="0" bgcolor="#000000"><tr><td>
<table cellpadding="8" cellspacing="0" border="0" bgcolor="lightgrey"
width="550"><tr><td>
<pre><tt>
<b>char</b> myframe[ MAX_MESSAGE_SIZE + MY_OVERHEAD ];
<b>int</b>  length;

 ...   <i>/* prepare frame contents for transmission */</i>
length = ... ;
result = CNET_write_physical(1, myframe, &amp;length);
</tt></pre></tr></td></table></td></tr></table>
<p>

Each link is also constrained in how many bytes may be written to it in
each call to <tt>CNET_write_physical</tt>.
This limit may be specified in the topology file,
using the link attribute <tt>transmitbufsize</tt>,
and may be detemined at run-time from the C variable
<tt>linkinfo[linkno].transmitbufsize</tt>.
Setting <tt>transmitbufsize</tt> to a small value, say 1KB,
will require your protocols to fragment large messages before sending them.
The default value of <tt>transmitbufsize</tt> (9KB),
is sufficient to handle the largest message generated by the Application
Layer (8KB),
and so fragmentation is not required in elementary protocols.

<p>
<IMG SRC="images/purple-line.gif" ALT="line" WIDTH="100%" HEIGHT=8 ALIGN=bottom>
<p>

When <i>cnet</i> informs the destination node that a frame has arrived,
the handler for <tt>EV_PHYSICALREADY</tt> should read that frame.
On return from a successful call to <tt>CNET_read_physical</tt>,
your protocol is informed on which link the frame arrived and how long it was.

<p>
<table cellpadding="1" cellspacing="0" border="0" bgcolor="#000000"><tr><td>
<table cellpadding="8" cellspacing="0" border="0" bgcolor="lightgrey"
width="550"><tr><td>
<pre><tt>
<b>char</b> myframe[ MAX_MESSAGE_SIZE + MY_OVERHEAD ];
<b>int</b>  link, length;

length = <b>sizeof</b>(myframe);
result = CNET_read_physical(&amp;link, myframe, &amp;length);
 ...   <i>/* process frame contents */</i>
</tt></pre></tr></td></table></td></tr></table>
<p>

Of course,
in a simple network with just one point-to-point link or one Ethernet segment,
all frames will be transmitted and will arrive on link number <tt>1</tt>.
Point-to-point links impose no particular format on the frames written to it;
unless corrupted or lost, whatever is written to a point-to-point link will
arrive unmodified, and without interpretation, at the other end of the link.
<p>
As an aid to debugging protocols,
the function <tt>CNET_write_physical()</tt> will 'trap' the situation
when a <i>large</i> number of frames have been written to the Physical Layer,
and when the receiving node has not read any of them off.
This trap is currently set at the large value of 1000,
which surely indicates an error in a protocol.
An errant protocol may have some unbounded loop,
or a very short timeout-and-retransmission sequence,
resulting in many calls to <tt>CNET_write_physical()</tt> at the sender,
before any <tt>EV_PHYSICALREADY</tt> events are handled at the receiver.
If the frame limit is exceeded,
<tt>CNET_write_physical()</tt> will return <tt>-1</tt>
and set <tt>cnet_errno</tt> to <tt>ER_TOOBUSY</tt>.

<p>
<IMG SRC="images/purple-line.gif" ALT="line" WIDTH="100%" HEIGHT=8 ALIGN=bottom>
<p>

To provide some sense of realism,
frames (or packets) written to Ethernet links are expected to carry the
address of their destination Network Interface Card (NIC) at the very
beginning of the frame.
<i>cnet</i> provides the data type <tt>CnetNicaddr</tt> to represent the
addresses of its NICs,
as an array of <tt>LEN_NICADDR</tt> (=6) unsigned characters.

<i>cnet</i> interprets the leading <tt>LEN_NICADDR</tt> bytes of each frame
on an Ethernet segment to be an address.
The special address, whose string representation is <tt>ff:ff:ff:ff:ff:ff</tt>,
is interpreted as the Ethernet <i>broadcast address</i>.
Any frame carrying the broadcast address as its destination address will be
delivered to all NICs on the Ethernet segment, except the sender.
<i>cnet</i> does not support multicast or group addressing.
<p>

Consider the following example function,
used to write data to an Ethernet segment:
<p>
<table cellpadding="1" cellspacing="0" border="0" bgcolor="#000000"><tr><td>
<table cellpadding="8" cellspacing="0" border="0" bgcolor="lightgrey"
width="550"><tr><td>
<pre><tt>
<b>typedef struct</b> {
    CnetNicaddr    dest;
    CnetNicaddr    src;
    <b>char</b>           type[2];
    <b>char</b>           data[ETH_MAXDATA];
} ETHERPACKET;

#define LEN_ETHERHEADER (2*sizeof(CnetNicaddr) + 2)

<b>static void</b> write_to_ethernet(CnetNicaddr dest, <b>int</b> link, <b>char</b> *buf, <b>int</b> len)
{
    ETHERPACKET packet;
    <b>short int</b>   twobytes;

    memcpy(packet.dest, dest,                   <b>sizeof</b>(CnetNicaddr));
    memcpy(packet.src,  linkinfo[link].nicaddr, <b>sizeof</b>(CnetNicaddr));

    twobytes = len;              <i>/* type carries the data's true length */</i>
    memcpy(packet.type, &amp;twobytes, 2);
    memcpy(packet.data, buf, len);

    len  += LEN_ETHERHEADER;
    <b>if</b>(len &lt; ETH_MINPACKET)      <i>/* pad short packets to minimum length */</i>
        len = ETH_MINPACKET;
    CHECK(CNET_write_physical(link, (<b>char</b> *)&amp;packet, &amp;len));
    ......
}
</tt></pre></tr></td></table></td></tr></table>
<p>
This function assumes that the data's length is not too long for Ethernet
(<tt>&lt;=&nbsp;ETH_MAXDATA</tt> (=1500) bytes).
The required destination's NIC address is first copied to the destination
address field,
and then the address of the local NIC used copied to the source address field.
Notice that because the <tt>CnetNicaddr</tt> type is actually an array of
characters, we do not use the &amp; operator in the calls to <tt>memcpy</tt>.

The data's true length is copied into the packet's two-byte <tt>type</tt>
field, the provided data copied to the packet's data.
After ensuring that the packet to be written is at least
<tt>ETH_MINPACKET</tt> (=64) bytes long,
the packet is written to the link.

Again, <i>cnet</i> does not enforce (nor understand) the use of
<i>our</i> <tt>ETHERPACKET</tt> data type,
but <i>does</i> assume that the first
<tt>LEN_NICADDR</tt> bytes of each packet provides the destination NIC address.
<p>

Two additional Physical Layer functions are provided to assist in the
debugging of multi-layered protocols.
<tt>CNET_write_physical_reliable</tt> is identical to
<tt>CNET_write_physical</tt> except that frames sent using it will not be
subject to frame corruption or loss.
It can be considered as a ``perfect'' Data Link Layer if you just want
to implement higher-layered protocols.
The function <tt>CNET_write_direct</tt> also bypasses all Physical Layer errors
and instructs a message to be sent directly to the node whose address is
specified as a parameter.
It thus provides perfect a Data Link Layer and Network Layer.

<p>
<IMG SRC="images/purple-line.gif" ALT="line" WIDTH="100%" HEIGHT=8 ALIGN=bottom>
<p>

<h3><a name="physical">Physical Layer functions</a></h3>

<dl>

<dt><a name="write_physical"><tt>
<b>int</b>
CNET_write_physical(<b>int</b> link, <b>char</b> *frame, <b>int</b> *len);
</tt>
</a>
</dt>
<dd>
<p>
Passes a number of bytes, pointed to by <tt>frame</tt> ``down to''
the Physical Layer
which will attempt to deliver them on the indicated <tt>link</tt> (wire).
Each node has a fixed number of links,
the first available link is number <tt>1</tt>,
the second is number <tt>2</tt>, and so on.
As a special case,
a node may <i>reliably</i> transmit a frame to itself by requesting
the <tt>LOOPBACK(=0)</tt> link.
On invocation, <tt>len</tt> must point to an integer indicating the number
of bytes to be taken from <tt>frame</tt>.
On return, <tt>len</tt> will point to an integer now indicating the number
of bytes accepted by the Physical Layer.
<p>
Possible errors: <tt>ER_BADARG, ER_BADLINK, ER_BADSIZE, ER_LINKDOWN,
ER_NOTREADY, ER_TOOBUSY.</tt>
<p>
</dd>

<dt><a name="write_physical_reliable"><tt>
<b>int</b>
CNET_write_physical_reliable(<b>int</b> link,
	<b>char</b> *frame, <b>int</b> *len);
</tt>
</a>
</dt>
<dd>
<p>
Identical to <tt>CNET_write_physical</tt> though the transmission is
guaranteed to be error free (providing a reliable data-link layer).
<p>
Possible errors: <tt>ER_BADARG, ER_BADLINK, ER_BADSIZE, ER_LINKDOWN,
ER_NOTREADY, ER_TOOBUSY.</tt>
<p>

<dt><a name="write_direct"><tt>
<b>int</b>
CNET_write_direct(CnetAddr destaddr, <b>char</b> *msg, <b>int</b> *len);
</tt>
</a>
</dt>
<dd>
<p>
Similar to <tt>CNET_write_physical_reliable</tt> but the network address of the
required destination node may be specified
(providing a reliable network/routing layer for asynchronous message passing).
Messages transmitted using <tt>CNET_write_direct</tt> are considered to be
transmitted on, and arrive on, link number <tt>1</tt>.
The special destination address <tt>BROADCAST</tt> may be used to transmit a
message to all nodes except the sender.
Regardless of the number of hops, propagation delays, and bandwidth,
all frames sent via <tt>CNET_write_direct</tt> reach their destination in
just 1msec.
<p>
Possible errors: <tt>ER_BADARG, ER_BADLINK, ER_BADSIZE, ER_LINKDOWN,
ER_NOTREADY, ER_TOOBUSY.</tt>
<p>

<dt><a name="read_physical"><tt>
<b>int</b>
CNET_read_physical(<b>int</b> *link, <b>char</b> *frame, <b>int</b> *len);
</tt>
</a>
</dt>
<dd>
<p>
Accepts the specified maximum number of bytes from the Physical Layer,
placing them in the address pointed to by <tt>frame</tt>.
On invocation, <tt>len</tt> must point to an integer indicating the maximum
number of bytes that may be copied into <tt>frame</tt>.
On return, <tt>len</tt> will point to an integer now indicating the number
of bytes taken from the Physical Layer
and <tt>link</tt> will point to an integer indicating on which link they
were received.
<p>
Possible errors: <tt>ER_BADARG, ER_BADSIZE, ER_CORRUPTDATA, ER_NOTREADY.</tt>
<p>

<dt><a name="set_promiscuous"><tt>
<b>int</b>
CNET_set_promiscuous(<b>int</b> link, <b>int</b> Boolean_value);
</tt>
</a>
</dt>
<dd>
<p>
This function places (or removes) the Network Interface Card (NIC)
of the indicated physical link into <i>promiscuous&nbsp;mode</i>.
When in promiscuous mode, the NIC will receive a copy of all frames on the
segment, even if they are neither broadcast frames or explicity addressed
to the NIC.
Promiscuous mode may only be set for links of type <tt>LT_ETHERNET</tt>,
not for <tt>LT_LOOPBACK&nbsp;(link=0)</tt> or <tt>LT_POINT2POINT</tt> links.
<p>
Possible errors: <tt>ER_BADLINK.</tt>
<p>

<dt><a name="set_nicaddr"><tt>
<b>int</b>
CNET_set_nicaddr(<b>int</b> link, CnetNicaddr new_nicaddr);
</tt>
</a>
</dt>
<dd>
<p>
This function sets the address recognized by the Network Interface Card (NIC)
of the indicated physical link.
The new address may not be the zero address, <tt>00:00:00:00:00:00</tt>,
or the broadcast address, <tt>ff:ff:ff:ff:ff:ff</tt>.
No check is made to ensure that the new address is unique within the network
(thereby enabling some snooping/sniffing protocols to be developed).
NIC addresses may only be set for links of type <tt>LT_ETHERNET</tt>,
not for <tt>LT_LOOPBACK&nbsp;(link=0)</tt> or <tt>LT_POINT2POINT</tt> links.
<p>
Possible errors: <tt>ER_BADARG, ER_BADLINK.</tt>
<p>

<dt><a name="parse_nicaddr"><tt>
<b>int</b>
CNET_parse_nicaddr(CnetNicaddr nicaddr, <b>char</b> *string);
</tt>
</a>
</dt>
<dd>
<p>
This function accepts a character string of the form
<tt>ab:cd:ef:gh:ij:kl</tt>,
where each letter is a valid hexadecimal character,
and converts this string representation to the ``internal'' form consisting
of an array of 6 unsigned characters.
Any valid Network Interface Card (NIC) address is accepted.
<p>
Possible errors: <tt>ER_BADARG.</tt>
<p>

<dt><a name="format_nicaddr"><tt>
<b>int</b>
CNET_format_nicaddr(<b>char</b> *buffer, CnetNicaddr nicaddr);
</tt>
</a>
</dt>
<dd>
<p>
This function accepts a Network Interface Card (NIC) address
and formats its `internal'' form to a string of characters of the form
<tt>ab:cd:ef:gh:ij:kl</tt>,
where each letter will be a hexadecimal character.
<p>
Possible errors: <tt>ER_BADARG.</tt>
<p>

</dl>

</td></tr></table>


<table width="100%"><tr>
  <td><i>cnet</i> was written and is maintained by Chris McDonald
      <A HREF="mailto:chris@csse.uwa.edu.au">(chris@csse.uwa.edu.au)</a></td>
  <td><img align="right" src="images/UWAsmall.gif"></td>
</tr></table>

</BODY>
</HTML>
