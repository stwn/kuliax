#if	!defined(_CNET_H)
#define	_CNET_H

#define	CNET_VERSION		"cnet v2.0.10"

/*  This is the standard '#include' file for the cnet simulator.
    DO NOT COPY this file, simply #include it into your cnet protocol files.

    Last modified: Tue Mar  7 02:58:53 WST 2006
 */

#include <stdio.h>
#include "cnet64bits.h"

/*  The cnet network simulator (v2.0.10)
    Copyright (C) 1992-2006, Chris McDonald

    Chris McDonald, chris@csse.uwa.edu.au
    Department of Computer Science & Software Engineering
    The University of Western Australia,
    Crawley, Western Australia, 6009
    PH: +61 8 9380 2533, FAX: +61 8 9380 1089.

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */


/* ------- Some constants and types used in cnet and its protocols ------- */

#define	MAX_NODENAME_LEN	32	/* len including terminating NULL */
#define	K			1024
#define	MAX_MESSAGE_SIZE	(8 * K)	/* largest msg (in bytes) that will be
					   generated by the Application Layer */
#define	ALLNODES		(0xFFFFFFFF)

typedef CnetUint32		CnetAddr;
typedef CnetInt32		CnetData;
typedef	CnetInt32		CnetTimer;
#define	NULLTIMER		(CnetTimer)0L

typedef enum	{ NT_HOST, NT_ROUTER }				CnetNodetype;
typedef enum	{ LT_LOOPBACK, LT_POINT2POINT, LT_ETHERNET }	CnetLinktype;



/* -------- these global variables should be considered READ-ONLY -------- */


typedef	struct {
    char	 nodename[MAX_NODENAME_LEN];
    CnetNodetype nodetype;	    /* Either NT_HOST or NT_ROUTER */
    int		 nodenumber;	    /* Ranging from 0.._NNODES-1 */
    CnetAddr	 address;	    /* Possibly different to the nodenumber */

    int		 nlinks;	    /* Ranging from 0(=LT_LOOPBACK) .. nlinks */
    int		 minmessagesize;    /* min size (in bytes) of msgs generated */
    int		 maxmessagesize;    /* max size (in bytes) of msgs generated */
    CnetInt64	 messagerate;	    /* rate of msg generation (in usecs) */

    CnetInt64	 time_in_usec;	    /* time since this node's last reboot */
    struct {
	long	 sec;		    /* seconds */
	long	 usec;		    /* microseconds */
    }		 time_of_day;	    /* the node's wall-clock time */
} CnetNodeinfo;

extern	CnetNodeinfo	nodeinfo;
extern	int		NNODES;	    /* only divulged if running as   cnet -N */


#define	LEN_NICADDR	6	    /* in bytes */
typedef	unsigned char	CnetNicaddr[LEN_NICADDR];

#define	ETH_MINDATA	46	    /* in bytes */
#define	ETH_MAXDATA	1500	    /* in bytes */
#define	ETH_MINPACKET	64	    /* in bytes */
#define	ETH_MAXPACKET	1518	    /* in bytes */

typedef struct {
    CnetLinktype  linktype;	    /* LT_LOOPBACK LT_POINT2POINT LT_ETHERNET */
    CnetNicaddr	  nicaddr;	    /* NIC address for LT_ETHERNET links */
    int           linkup;	    /* TRUE iff link not severed */
    int           promiscuous;	    /* TRUE iff LT_ETHERNET sees all frames */

    int           bandwidth;	    /* in bits per second */
    int           transmitbufsize;  /* in bytes */
    CnetInt64	  propagationdelay; /* in microseconds */
    int           costperbyte;	    /* in cents(?) */
    int           costperframe;	    /* in cents(?) */
} CnetLinkinfo;

extern  CnetLinkinfo *linkinfo;     /* linkinfo[0]..linkinfo[nodeinfo.nlinks] */


#define	CN_GREEN		1	/* order must match that in cnet.tcl */
#define	CN_PURPLE		2
#define	CN_CYAN			3
#define	CN_RED			4
#define	CN_YELLOW		5
#define	CN_BLUE			6
#define	CN_NCOLOURS		6

#define	DRAWFRAME_TEXTLEN	16	/* len including terminating NULL */

typedef struct {
    int         len;			/* the length of the frame presented */
    char        *frame;			/* a pointer to the frame */
    int         colour[CN_NCOLOURS];	/* request up to CN_NCOLOURS */
    int         pixels[CN_NCOLOURS];	/* draw with these required lengths */
    char	text[DRAWFRAME_TEXTLEN];/* text centred on moving frame */
} CnetDrawFrame;


/* ------ these enumerated values should be used (and not changed!) ----- */


typedef enum {
    EV_NULL = 0,	/* this event is never raised. */
    EV_REBOOT,		/* raised as reboot_node(EV_REBOOT, ... , ...) */
    EV_SHUTDOWN,	/* raised before cnet is (cleanly) terminated */

    EV_APPLICATIONREADY,/* raised when there is a msg ready for delivery */
    EV_PHYSICALREADY,	/* raised when a frame arrives at one of the links */
    EV_KEYBOARDREADY,	/* raised when a line entered from the keyboard */
    EV_LINKSTATE,	/* raised when a link changes state */
    EV_DRAWFRAME,	/* raised when a frame is to be drawn in 2-node world */

    EV_DEBUG1,	EV_DEBUG2,	EV_DEBUG3,	EV_DEBUG4,	EV_DEBUG5,

    EV_TIMER1,	EV_TIMER2,	EV_TIMER3,	EV_TIMER4,	EV_TIMER5,
    EV_TIMER6,	EV_TIMER7,	EV_TIMER8,	EV_TIMER9,	EV_TIMER10
} CnetEvent;

typedef enum {
    ER_OK = 0,		/* No error */
    ER_BADARG,		/* Invalid argument passed to a function */
    ER_BADEVENT,	/* Invalid event passed to a function */
    ER_BADLINK,		/* Invalid link number passed to a function */
    ER_BADNODE,         /* Invalid node passed to a function */
    ER_BADSENDER,	/* Application Layer given msg from an unknown node */
    ER_BADSESSION,	/* Application Layer given msg from incorrect session */
    ER_BADSIZE,		/* Indicated length is of incorrect size */
    ER_BADTIMER,	/* Invalid CnetTimer passed to a function */
    ER_CORRUPTDATA,	/* Attempt to transfer corrupt data */
    ER_LINKDOWN,	/* Attempt to transmit on a link that is down */
    ER_NOTFORME,	/* Application Layer given a msg for another node */
    ER_NOTREADY,	/* Function called when service not available */
    ER_NOTSUPPORTED,	/* Invalid operation for this node type */
    ER_OUTOFSEQ,	/* Application Layer given msg out of sequence */
    ER_TOOBUSY		/* Function is too busy/congested to handle request */
} CnetError;

extern	CnetError	cnet_errno;
extern	char		*cnet_errname[], *cnet_errstr[], *cnet_evname[]; 
extern	void		CNET_perror(char *string);

	/* Most functions in cnet return a zero on their success, and a -1
	   on failure. The reason for any failure is reflected in the
	   global variable cnet_errno.  cnet_errno may also be used as an
	   integral index into the arrays cnet_errname and cnet_errstr to
	   enable more detailed error reporting.  The function CNET_perror
	   prints its string argument, preceeded by the last known error. */


#define	N_CNET_DEBUGS	 5
#define	N_CNET_ERRORS	16
#define	N_CNET_EVENTS	23
#define	N_CNET_TIMERS	10

#define	IS_DEBUG(ev)	((int)EV_DEBUG1<=(int)ev && (int)ev<=(int)EV_DEBUG5)
#define	IS_TIMER(ev)	((int)EV_TIMER1<=(int)ev && (int)ev<=(int)EV_TIMER10)


/* -------- Functions for communicating with the network and timers ----- */


extern	int CNET_set_handler(CnetEvent ev, void (*handler)(), CnetData data);

	/* Register handler as the void ``returning'' function to be invoked
	   when the event ev occurs. When the handler is invoked, it will
	   be passed the event, a timer and the user-specified data. */

extern	int CNET_get_handler(CnetEvent ev, void (**handler)(), CnetData *data);

	/* Obtains the address of the void ``returning'' function which will
	   be invoked when the indicated event occurs, together with the
	   user-specified data value that will be passed to the handler. */

extern	int CNET_read_application(CnetAddr *destaddr, char *msg, int *len);

	/* On invocation, len will point to an integer indicating the maximum
	   number of bytes that may be copied into msg.  On return, len will
	   point to an integer now indicating the number of bytes copied into
	   msg.  The address of the required destination node is copied
	   into destaddr. */

extern	int CNET_write_physical(int link, char *frame, int *len);

	/* Passes a number of bytes, pointed to by frame ``down to'' the
	   physical layer which will attempt to deliver them on the indicated
	   link (wire).  Each node has a fixed number of links, the first
	   available link is number 1, the second is number 2, and so on.
	   As a special case, a node may reliably transmit a frame to itself by
	   requesting an LT_LOOPBACK link (number 0).  On invocation, len will
	   point to an integer indicating the number of bytes to be taken from
	   frame. On return, len will point to an integer now indicating the
	   number of bytes accepted by the physical layer. */

extern	int CNET_write_physical_reliable(int link, char *frame, int *len);

	/* CNET_write_physical_reliable() performs an identical function to
	   CNET_write_physical() but will never introduce any corruption or
	   loss (thus providing a reliable datalink layer). */

extern	int CNET_write_direct(CnetAddr destaddr, char *frame, int *len);

	/* CNET_write_direct() performs identically to
	   CNET_write_physical_reliable() although the address of the required
	   destination node must be specified (providing a reliable network
	   layer).  All directly written frames arrive on link 1 in the
	   destination.  */

extern	int CNET_read_physical(int *link, char *frame, int *len);

	/* Accepts the specified maximum number of bytes from the physical
	   layer, placing them in the address pointed to by frame.
	   On invocation, len will point to an integer indicating the maximum
	   number of bytes that may be copied into frame.  On return, len will
	   point to an integer now indicating the number of bytes taken from
	   the physical layer and link will point to an integer indicating on
	   which link they were received. */

extern	int CNET_set_nicaddr(int link, CnetNicaddr nicaddr);

	/* Sets the network interface card's addreess for the indicated link
	   Setting a nicaddr is only really meaningful for Ethernet links. */

extern	int CNET_set_promiscuous(int link, int newvalue);

	/* Sets the indicated link to promiscuous mode (if newvalue=TRUE)
	   or otherwise (if newvalue=FALSE).  Setting a link to promiscuous
	   mode is only really meaningful for Ethernet links. */

extern	int CNET_write_application(char *msg, int *len);

	/* Passes a number of bytes, pointed to by msg, ``up to'' the
	   application layer. On invocation, len must point to an integer
	   indicating the number of bytes to be taken from msg.
	   On return, len will point to an integer now indicating the number
	   of bytes accepted by the application layer. */

extern	int CNET_enable_application(CnetAddr destaddr);

	/* Permits the application layer to generate messages for the node
	   with the indicated address. Initially, msg generation for all nodes
	   is disabled and must be enabled to begin the generation of msgs.
	   If destaddr == ALLNODES, message generation will be enabled
	   for all nodes.  */

extern	int CNET_disable_application(CnetAddr destaddr);

	/* Prevents the application layer from generating new messages for the
	   node with the indicated address. This function should be called
	   when a harried node runs out of buffer space, or perhaps while
	   routing information is being gathered.  If destaddr == ALLNODES,
	   message generation will be disabled for all nodes.  */

extern CnetTimer CNET_start_timer(CnetEvent ev, CnetInt64 usecs, CnetData data);

	/* Requests that a new timer be created which will expire in the
	   indicated number of microseconds.  When the timer expires, the
	   handler for the indicated event, EV_TIMER1..EV_TIMER10, will be
	   called together with the user-specified data value.
	   A unique timer is returned to distinguish this newly created
	   timer from all others. This timer may later be used in
	   subsequent calls to CNET_stop_timer() or CNET_timer_data(). */

extern	int CNET_stop_timer(CnetTimer timer);

	/* Requests that the indicated timer be cancelled. */

extern	int CNET_timer_data(CnetTimer timer, CnetData *data);

	/* Allows the CnetData value for the indicated CnetTimer value
	   to be recovered. The timer is not cancelled. */

extern	int CNET_read_keyboard(char *line, int *len);

	/* Requests the specified maximum number of bytes from the keyboard
	   buffer and places them in the address pointed to by line.
	   On invocation, len will point to an integer indicating the maximum
	   number of bytes that may be copied into line. On return, line
	   will be NULL-byte terminated (and not include a newline) and the
	   integer pointed to by len will contain strlen(line)+1. */

extern	int CNET_set_time_of_day(long newsec, long newusec);

	/* Changes the node's notion of the wall-clock time of day.
	   time_of_day.sec is the number of seconds since Jan. 1, 1970,
	   and may be used in a call to ctime(3c).
	   As nodeinfo should be considered a read-only structure, this is
	   the only method to set time_of_day.sec and time_of_day.usec . */

extern	int CNET_set_debug_string(CnetEvent ev, char *str);

	/* Changes the string on the required debug button, indicated by the
	   event EV_DEBUG1..EV_DEBUG5, to the indicated string.
	   Passing the NULL or empty string will remove the button. */

extern	void CNET_exit(const char *filenm, const char *function, int lineno);

	/* Calling this function will exit (all of) cnet, and display the
	   invoking node's name, source file, function, and line where it
	   was called, together with the latest cnet_errno value. */

extern		 int	CNET_format_nicaddr(char *buf, CnetNicaddr nicaddr);
extern		 int	CNET_parse_nicaddr (CnetNicaddr nicaddr, char *buf);

extern	unsigned short	checksum_ccitt(unsigned char *addr, int nbytes);
extern	unsigned short	checksum_crc16(unsigned char *addr, int nbytes);
extern	unsigned long	checksum_crc32(unsigned char *addr, int nbytes);
extern		 int	checksum_internet(unsigned short *addr, int nbytes);


/* --- Next, constants and declarations for debugging and event tracing --- */

#define	TE_NOEVENTS		(0)
#define	TE_ALLEVENTS		(1)
#define	TE_REBOOT		(1<<(int)EV_REBOOT)
#define	TE_SHUTDOWN		(1<<(int)EV_SHUTDOWN)
#define	TE_APPLICATIONREADY	(1<<(int)EV_APPLICATIONREADY)
#define	TE_PHYSICALREADY	(1<<(int)EV_PHYSICALREADY)
#define	TE_KEYBOARDREADY	(1<<(int)EV_KEYBOARDREADY)
#define	TE_LINKSTATE		(1<<(int)EV_LINKSTATE)
#define	TE_DRAWFRAME		(1<<(int)EV_DRAWFRAME)
#define	TE_DEBUG1		(1<<(int)EV_DEBUG1)
#define	TE_DEBUG2		(1<<(int)EV_DEBUG2)
#define	TE_DEBUG3		(1<<(int)EV_DEBUG3)
#define	TE_DEBUG4		(1<<(int)EV_DEBUG4)
#define	TE_DEBUG5		(1<<(int)EV_DEBUG5)
#define	TE_TIMER1		(1<<(int)EV_TIMER1)
#define	TE_TIMER2		(1<<(int)EV_TIMER2)
#define	TE_TIMER3		(1<<(int)EV_TIMER3)
#define	TE_TIMER4		(1<<(int)EV_TIMER4)
#define	TE_TIMER5		(1<<(int)EV_TIMER5)
#define	TE_TIMER6		(1<<(int)EV_TIMER6)
#define	TE_TIMER7		(1<<(int)EV_TIMER7)
#define	TE_TIMER8		(1<<(int)EV_TIMER8)
#define	TE_TIMER9		(1<<(int)EV_TIMER9)
#define	TE_TIMER10		(1<<(int)EV_TIMER10)

extern	int	CNET_set_trace(int);
extern	int	CNET_get_trace(void);

	/* CNET_set_trace enables only certain event types to be traced;
	   multiple event types may be ORed together, for example:
	   TE_APPLICATIONREADY | TE_PHYSICALREADY.
	   Invoking cnet with the -t option, is equivalent to calling
	   CNET_set_trace(TE_ALLEVENTS).
	   CNET_get_trace returns the current node's event trace mask. */

extern	int	CNET_trace(const char *, ...);

	/* When tracing is enabled in any node, CNET_trace may be called
	   to display any arbitary string or debug output, which will be
	   indented by one tab. It employs a printf-like interface. */

extern	int	CNET_trace_name(void *addr, const char *name);

	/* When tracing is enabled in any node, memory addresses are, by
	   default, printed as hexadecimal values. CNET_trace_name
	   associates an address (typically that or a variable) and a string
	   (typically the name of that variable).  When tracing is enabled,
	   the given string will be printed in for its hexadecimal value. */


/* ---------------------- Some helpful macros ------------------------- */

#if	defined(__GNUC__)
#define CHECK(call)	do { if((call) != 0) \
			CNET_exit(__FILE__, __FUNCTION__, __LINE__);} while(0)
#else
#define CHECK(call)	do { if((call) != 0) \
			CNET_exit(__FILE__, (char *)NULL, __LINE__);} while(0)
#endif

	/* By enveloping most calls to cnet's library routines we can get
	   an accurate and immediate report on the location (source file +
	   line number + nodename) and type of each error. If using the
	   GNU C compiler, we can also determine the function name in
	   which the error occurred. These helpful values are passed to
	   cnet's function CNET_exit which, if able, pops up a window
	   highlighting the file and line number of the runtime error. */


/* ----------------- Finally, the STDIO window definitions ------------ */


#if	defined(putchar)
#undef	putchar
#endif

/* These functions are supported: */
extern	void	CNET_clear(void);
extern	int	putchar(int ch);
extern	int	puts(const char *str);

#if	!defined(__OPTIMIZE__)
extern	int	printf(const char *fmt, ...);
#endif

/* Since cnet v1.6, the following functions are no longer supported: */
extern	int	CNET_set_cursor(int  row, int  col);
extern	int	CNET_get_cursor(int *row, int *col);
extern	void	CNET_clear_to_eoln(void);
extern	void	CNET_clear_to_eos(void);

#endif
